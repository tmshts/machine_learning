# -*- coding: utf-8 -*-
"""runt_task1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xZa_kDnZoDHyciAkPAGXYy-bWhIU_HLr
"""

import os
import urllib.request as http
from zipfile import ZipFile
import tensorflow as tf
import numpy as np
from PIL import Image
from tensorflow.keras.datasets import cifar10
from tensorflow.keras.models import save_model, load_model
from sklearn.model_selection import train_test_split
from tensorflow.keras import utils


def load_cifar10(num_classes=3):
    """
    Downloads CIFAR-10 dataset, which already contains a training and test set,
    and return the first `num_classes` classes.
    Example of usage:

    >>> (x_train, y_train), (x_test, y_test) = load_cifar10()

    :param num_classes: int, default is 3 as required by the assignment.
    :return: the filtered data.
    """
    (x_train_all, y_train_all), (x_test_all, y_test_all) = cifar10.load_data()

    fil_train = tf.where(y_train_all[:, 0] < num_classes)[:, 0]
    fil_test = tf.where(y_test_all[:, 0] < num_classes)[:, 0]

    y_train = y_train_all[fil_train]
    y_test = y_test_all[fil_test]

    x_train = x_train_all[fil_train]
    x_test = x_test_all[fil_test]

    return (x_train, y_train), (x_test, y_test)

if __name__ == '__main__':

    # Load the test CIFAR-10 data
    (x_train, y_train), (x_test, y_test) = load_cifar10(num_classes=3)


    # Preprocessing

    # use 20% of the training data as validation set
    x_train, x_val, y_train, y_val = train_test_split(x_train, y_train, test_size=0.2, random_state=4)

    #print('Training, validation, test samples: {}, {}, {}'.format(len(x_train), len(x_val), len(x_test)))
    #print('Training, validation, test samples: {}, {}, {}'.format(len(y_train), len(y_val), len(y_test)))

    # Normalize to 0-1 range
    #print(x_train)
    x_train = x_train.astype('float32') / 255.
    x_val = x_val.astype('float32') / 255.
    x_test = x_test.astype('float32') / 255.
    #print(x_train.shape)
    #print(x_val.shape)
    #print(x_test.shape)

    # one-hot encoding of the labels
    n_classes = 3
    y_train = utils.to_categorical(y_train, n_classes)
    y_val = utils.to_categorical(y_val, n_classes)
    y_test = utils.to_categorical(y_test, n_classes)
    #print(y_train.shape)
    #print(y_val.shape)
    #print(y_test.shape)


    # Load the trained models (one or more depending on task and bonus)
    # for example

    #from google.colab import drive
    #drive.mount('/content/drive')

    #MODEL_PATH = './drive/My Drive/Colab/USI/machine_learning/assignments/2/nn_task1.h5'
    MODEL_PATH = './nn_task1.h5'
    model_task1 = load_model(MODEL_PATH)

    # Predict on the given samples
    # for example
    # y_pred_task1 gives me probabilities for the 3 classes in each row -> I need to convert them into binary code (max value has 1)
    y_pred_task1 = model_task1.predict(x_test)
    #print(y_pred_task1)
    #print(y_test)
    #print(new_y)

    # Create new array with the same shape like y_pred_task1
    shape = y_pred_task1.shape
    new_y = np.zeros(shape)

    #print(new_y.shape)

    # create list for max values in each row -> max value in each row represents the fact, that this class is beeing predicted for the image
    max_values_list = []
    for row in y_pred_task1:
      max_values_list.append(max(row))

    #print(max_values_list)

    # iterate through the y_pred_task1 and replace the values with 0s or 1s
    for i in range(len(y_pred_task1)):
      #print(i)
      max_value = max_values_list[i]
      for k in range(len(y_pred_task1[1])):
        #print(k)
        #print(y_pred_task1[i][k])
        if y_pred_task1[i][k] == max_values_list[i]:
          new_y[i][k] = 1
          #print(new_y[i][k])
        else:
          new_y[i][k] = 0
          #print(new_y[i][k])

    #print(new_y)
    #print(y_test)

    # Evaluate the missclassification error on the test set
    # for example
    # our prediction is compared to the correct images
    assert y_test.shape == new_y.shape
    acc1 = (y_test == new_y).mean()
    print("Accuracy model task 1:", acc1)